#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
File name: scanESbyNGSFuncs.py
Author: CrazyHsu @ crazyhsu9527@gmail.com 
Created on: 2020-01-03 15:35:51
Last modified: 2020-01-03 15:35:52
'''

from itertools import chain, combinations
from commonObjs import Position, Bed12
from commonFuncs import *
novel_count = 0


class Junction(Bed12):
    """
    junction generated by tophat, with 5' donor and 3' acceptor attribute,
    (donor, acceptor) resembles the intron inside junction.
    """
    def __init__(self, line):
        Bed12.__init__(self, line)
        self.donor = self.chromStart + self.blockSizes[0]
        self.acceptor = self.chromStart + self.blockStarts[1]
        self.jPos = "%s:%d-%d" % (self.chrom, self.donor, self.acceptor)
        self.dn = self.donor if self.strand == "+" else self.acceptor
        self.ac = self.acceptor if self.strand == "+" else self.donor
        self.dnPos = "%s:%d:%s" % (self.chrom, self.dn, self.strand)

class SE(Bed12):
    "SE events identified by RNA-seq and supported by reference or pacbio"
    def __init__(self, bed12_se, junc_left, junc_right):
        Bed12.__init__(self, repr(bed12_se))
        self.junc_left = junc_left
        self.junc_right = junc_right
        self.junction = Position("%s:%d-%d" % (self.chrom, junc_left, junc_right))
        donor = junc_left if self.strand == "+" else junc_right
        self.jpos = repr(self.junction)
        self.dnpos = "%s:%d:%s" % (self.chrom, donor, self.strand)
        self.posCode = "%d@%s@%d" % (self.junc_left, ";".join(["%d-%d" % (st,ed) for (st,ed) in zip(self.exonStarts, self.exonEnds)]), self.junc_right)
        self.supCount = 0
        self.totalCount = 0

    def __repr__(self):
        return "\t".join([Bed12.__repr__(self), repr(self.supCount),
                          repr(self.totalCount), self.jpos])


def find_refs(chrom, strand, dn, ac_i, ac_o, refDct, dnpos2count):
    "return a list of ref matching input situation"
    if chrom not in refDct:
        return []

    refLst = refDct[chrom]
    refs = []
    left = min(dn, ac_o)
    right = max(dn, ac_o)
    for ref in refLst:
        if ref.strand != strand:
            continue
        elif ref.exonStarts[0] >= right or ref.exonEnds[-1] <= left:
            continue
        else:
            if strand == "+":
                if (dn in ref.exonEnds and ac_i in ref.exonStarts and ac_o in ref.exonStarts):
                    # refs.append(ref)
                    ac_o_index = ref.exonStarts.index(ac_o)
                    dnPos = "%s:%d:%s" % (chrom, ref.exonEnds[ac_o_index - 1], strand)
                    if dnPos in dnpos2count:
                        refs.append(ref)
            else:
                if (dn in ref.exonStarts and ac_i in ref.exonEnds and ac_o in ref.exonEnds):
                    # refs.append(ref)
                    ac_o_index = ref.exonEnds.index(ac_o)
                    dnPos = "%s:%d:%s" % (chrom, ref.exonEnds[ac_o_index - 1], strand)
                    if dnPos in dnpos2count:
                        refs.append(ref)
    return refs

def se_structure(strand, dn, ac_i, ac_o, ref):
    "return SE events (in SE object) in ref"
    left = min([ac_i, ac_o])
    right = max([ac_i, ac_o])

    bed = Bed12()
    bed.chrom = ref.chrom
    bed.strand = strand
    exSts = []
    exEds = []
    for st, ed in zip(ref.exonStarts, ref.exonEnds):
        if st >= left and ed <= right:
            exSts.append(st)
            exEds.append(ed)
        elif st >= right:
            break
    bed.exonStarts = exSts
    bed.exonEnds = exEds
    bed.chromStart = bed.thickStart = exSts[0]
    bed.chromEnd = bed.thickEnd = exEds[-1]
    bed.blockStarts = getRelStarts(exSts)
    bed.blockSizes = getSizes(exSts, exEds)
    bed.blockCount = len(exSts)

    if strand == "+":
        junc_left = dn
        junc_right = ac_o
    else:
        junc_left = ac_o
        junc_right = dn
    se = SE(bed, junc_left, junc_right)
    return se

def remove_redun(seLst):
    """return a sublist of seLst with redundent ones (same block and junction)
     removed"""
    newSes = []
    seCodeSet = set()    # se.posCode: dn@st-ed@ac
    for se in seLst:
        if se.posCode in seCodeSet:
            continue
        else:
            newSes.append(se)
            seCodeSet.add(se.posCode)
    return newSes

def union_ses(refSes, pbSes):
    """return a list of se which is the union of the 2 ses without redundency,
    change name of the se if necessary"""
    uSes = []
    seCodeSet = set()
    for se in refSes:
        se.name = "%s:%s" % (se.geneName, se.posCode)
        seCodeSet.add(se.posCode)
        uSes.append(se)

    for se in pbSes:
        if se.posCode in seCodeSet:
            continue
        else:
            global novel_count
            novel_count += 1
            se.name = "NovelSE_%d:%s" % (novel_count, se.posCode)
            seCodeSet.add(se.posCode)
            uSes.append(se)
    return uSes

def cal_psi(se, jpos2count, dnpos2count):
    "calculate supCount, totalCount and score for se"
    se.supCount = jpos2count[se.jpos]
    se.totalCount = sum([tup[1] for tup in dnpos2count[se.dnpos]])
    se.score = int(float(se.supCount)/se.totalCount * 1000)

def identify_ses(chrom, strand, dn, ac_i, ac_o, refDct, pbDct, jpos2count, dnpos2count):
    """return a list of bed12+ of SEs, additional fields: jpos, dnpos.
    """
    # find refs or pacbio reads covering dn to ac_o
    has_ref = False
    has_pb = False

    refs = find_refs(chrom, strand, dn, ac_i, ac_o, refDct, dnpos2count)
    if refs:
        has_ref = True
    pbs = find_refs(chrom, strand, dn, ac_i, ac_o, pbDct, dnpos2count)
    if pbs:      # use pacbio reads to varify SE structure
        has_pb = True

    if not has_ref and not has_pb:
        return []

    # check se for each ref or pb
    refSes = []
    if has_ref:
        for ref in refs:
            se = se_structure(strand, dn, ac_i, ac_o, ref)
            se.geneName = ref.geneName
            refSes.append(se)
    pbSes = []
    if has_pb:
        for pb in pbs:
            se = se_structure(strand, dn, ac_i, ac_o, pb)
            pbSes.append(se)

    # remove redun in refSe and pbSe, then remove redun in between
    refSes = remove_redun(refSes)
    pbSes = remove_redun(pbSes)
    seLst = union_ses(refSes, pbSes)

    # add score and return
    # out = open(outFile, "w")
    newSeLst = []
    for se in seLst:
        cal_psi(se, jpos2count, dnpos2count)
        newSeLst.append(se)
        # print >>out, se
    return newSeLst
    # out.close()
    # return 0

def check_ses(chrom, dn, acs, refDct, pbDct, jpos2count, dnpos2count):
    """return a list of SE(Bed12+) for enumerated dn-ac(ac is element in acs)
    that can be supported by ref in refLst or pb in pbLst.
    """
    # sort acs by position
    acs.sort()

    # check SE for dn with each 2 acs
    strand = "+" if dn < acs[0] else "-"
    seLst = []
    for ac1, ac2 in combinations(acs, 2):
        if strand == "+":
            ac_i, ac_o = ac1, ac2
        else:
            ac_i, ac_o = ac2, ac1
        seLst.extend(identify_ses(chrom, strand, dn, ac_i, ac_o, refDct, pbDct, jpos2count, dnpos2count))
    return seLst
