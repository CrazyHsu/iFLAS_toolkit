from commonObjs import *
from commonFuncs import *
import itertools, pybedtools
import pandas as pd
import numpy as np
from itertools import combinations
from collections import Counter

class Junction(Bed12):
    """
    junction generated by tophat, with 5' donor and 3' acceptor attribute,
    (donor, acceptor) resembles the intron inside junction.
    """

    def __init__(self, line):
        Bed12.__init__(self, line)
        self.donor = self.chromStart + self.blockSizes[0]
        self.acceptor = self.chromStart + self.blockStarts[1]
        self.jPos = "%s:%d-%d" % (self.chrom, self.donor, self.acceptor)
        self.dn = self.donor if self.strand == "+" else self.acceptor
        self.ac = self.acceptor if self.strand == "+" else self.donor
        self.dnPos = "%s:%d:%s" % (self.chrom, self.dn, self.strand)


class Position(object):
    "chr:st-ed, zero based"

    def __init__(self, line):
        self.chrom, st_ed = line.strip().split(":")
        self.chromStart, self.chromEnd = (int(c) for c in st_ed.split("-"))
        assert self.chromStart < self.chromEnd

    def __repr__(self):
        return "%s:%d-%d" % (self.chrom, self.chromStart, self.chromEnd)


class SE(Bed12):
    "SE events identified by RNA-seq and supported by reference or pacbio"

    def __init__(self, bed12_se, junc_left, junc_right):
        Bed12.__init__(self, repr(bed12_se))
        self.junc_left = junc_left
        self.junc_right = junc_right
        self.junction = Position("%s:%d-%d" % (self.chrom, junc_left, junc_right))
        donor = junc_left if self.strand == "+" else junc_right
        self.jpos = repr(self.junction)
        self.dnpos = "%s:%d:%s" % (self.chrom, donor, self.strand)
        self.posCode = "%d@%s@%d" % (
        self.junc_left, ";".join(["%d-%d" % (st, ed) for (st, ed) in zip(self.exonStarts, self.exonEnds)]),
        self.junc_right)
        self.supCount = 0
        self.totalCount = 0

    def __repr__(self):
        return "\t".join([Bed12.__repr__(self), repr(self.supCount),
                          repr(self.totalCount), self.jpos])


#########################################
def drawSSmotif(asMotif=None, outPrefix=None, asType="IR"):
    with open(asMotif) as f:
        lineList = f.readlines()
        mySum = sum([int(i.strip("\n").split("\t")[1]) for i in lineList])
        tmp = open("{}.tmp.txt".format(outPrefix), "w")
        if len(lineList) < 4:
            for i in lineList:
                lineInfo = i.strip("\n").split("\t")
                if asType == "A3SS":
                    spliceSite = "-{}".format(lineInfo[0])
                elif asType == "A5SS":
                    spliceSite = "{}-".format(lineInfo[0])
                else:
                    spliceSite = lineInfo[0]
                print >> tmp, "\t".join([spliceSite, str(float(lineInfo[1])/mySum)])
        else:
            for i in lineList[0:3]:
                lineInfo = i.strip("\n").split("\t")
                if asType == "A3SS":
                    spliceSite = "-{}".format(lineInfo[0])
                elif asType == "A5SS":
                    spliceSite = "{}-".format(lineInfo[0])
                else:
                    spliceSite = lineInfo[0]
                print >> tmp, "\t".join([spliceSite, str(float(lineInfo[1]) / mySum)])
            otherSum = sum([int(i.strip("\n").split("\t")[1]) for i in lineList[3:]])
            print >> tmp, "\t".join(["Other", str(float(otherSum)/mySum)])
        tmp.close()
        cmd = "cat {}.tmp.txt | bar.R -fillV=V1 -fp -lgPos=top -w=12 -p={}.ssMotif.pdf 2>/dev/null".format(outPrefix, outPrefix)
        subprocess.call(cmd, shell=True, executable="/bin/bash")
        # os.remove("tmp.txt")
        # os.remove(asMotif)

def getAnnoASList(inFile, outFile, PA=False, append=False, uniq=False):
    with open(inFile) as f:
        if not append:
            out = open(outFile, "w")
        else:
            out = open(outFile, "w+")
        asLst = []
        if not PA:
            for line in f:
                if "Novel" in line: continue
                lineInfo = line.strip("\n").split("\t")
                asEvent = "{}:{}:{}".format(lineInfo[0], lineInfo[3], lineInfo[5])
                if uniq:
                    if asEvent not in asLst:
                        asLst.append(asEvent)
                    else:
                        continue
                print >>out, asEvent
        else:
            for line in f:
                lineInfo = line.strip("\n").split("\t")
                paPos = lineInfo[3].split(",")
                if len(paPos) > 1:
                    asEvent = ":".join(lineInfo[0:4])
                    if uniq:
                        if asEvent not in asLst:
                            asLst.append(asEvent)
                        else:
                            continue
                    print >>out, asEvent
        out.close()

def getASstatistics(asType="IR", asFile=None, annoFile=None, novelFile=None, outFile=None):
    out = open(outFile, "w")
    if asType == "PA":
        print >> out, "#Chr\tStrand\tKnown or Novel\tGene\tPA Sites"
        with open(annoFile) as f1:
            for line in f1:
                lineInfo = line.strip("\n").split("\t")
                if len(lineInfo[3].split(",")) > 1:
                    print >>out, "\t".join([lineInfo[0], lineInfo[1], "Known", lineInfo[2], lineInfo[3]])
        with open(novelFile) as f2:
            for line in f2:
                lineInfo = line.strip("\n").split("\t")
                if len(lineInfo[3].split(",")) > 1:
                    print >>out, "\t".join([lineInfo[0], lineInfo[1], "Novel", lineInfo[2], lineInfo[3]])
    else:
        asDict = {}
        with open(asFile) as f:
            for line in f:
                lineInfo = line.strip("\n").split("\t")
                key = ":".join([lineInfo[0], lineInfo[3], lineInfo[5]])
                asDict[key] = "\t".join([key, line.strip("\n")])
        annoList = filterFile(originFile=annoFile, targetFile=asDict, returnFlag=True)
        novelList = filterFile(originFile=novelFile, targetFile=asDict, returnFlag=True)
        os.remove("filtered.txt")
        geneCol = 7
        if asType == "IR":
            print >> out, "##AS ID is composed of Gene:Retained intron start-Retained intron end"
        elif asType == "SE":
            geneCol = 13
            print >> out, "##AS ID is composed of Gene:Left flanking constitutive exon end@Alternative exons locus@Right flanking constitutive exon start"
            print >> out, "##Alternative exons locus is composed of Alternative exon1 start-Alternative exon1 end[;Alternative exon2 start-Alternative exon2 end[;Alternative exon3 start-Alternative exon3 end...]"
        elif asType == "A3SS":
            print >> out, "##AS ID is composed of Gene:Alternative 5' splicing region start-Alternative 5' splicing region end"
        elif asType == "A5SS":
            print >> out, "##AS ID is composed of Gene:Alternative 3' splicing region start-Alternative 3' splicing region end"
        print >> out, "#Chr\tStrand\tKnown or Novel\tAS ID\tGene"

        for i in annoList:
            tmpList = asDict[i].strip().split("\t")
            print >> out, "\t".join([tmpList[1], tmpList[6], "Known", tmpList[4], tmpList[geneCol]])
        for i in novelList:
            tmpList = asDict[i].strip().split("\t")
            print >> out, "\t".join([tmpList[1], tmpList[6], "Novel", tmpList[4], tmpList[geneCol]])

    out.close()

def getDist2TTS(refParams=None, paGroup=None):
    with open(paGroup) as f:
        out = open("pbPA.bed6", "w")
        for line in f:
            lineInfo = line.strip("\n").split("\t")
            if lineInfo[5] == "+":
                print >>out, "\t".join(map(str, [lineInfo[0], int(lineInfo[2])-1, lineInfo[2]] + lineInfo[3:]))
            else:
                print >>out, "\t".join(map(str, [lineInfo[0], lineInfo[1], int(lineInfo[1])+1] + lineInfo[3:]))
        out.close()
    cmd = '''
        bedtools closest -a <(sort -k1,1 -k2,2n pbPA.bed6) -b <(gpeFeature.pl --tts {}|
        sort -k1,1 -k2,2n) -s -D a | select.pl -i 13,4 | sort -u | tee pbPA2TTS.tsv | 
        cut -f1 | box.R -ng -nJ -no -y='Distance to TTS' -p=pbPA2TTS.pdf
    '''.format(refParams.ref_gpe)
    subprocess.call(cmd, shell=True, executable="/bin/bash")

def getSpliceSite(asType=None, asFile=None, outFile=None):
    if asType == "IR":
        out = open(outFile, "w")
        with open(asFile) as f:
            for line in f:
                lineInfo = line.strip("\n").split(":")
                posList = lineInfo[2].split("-")
                print >>out, "\t".join([lineInfo[0], posList[0], posList[1], lineInfo[3]])
        out.close()
    elif asType == "SE":
        cmd = "seDecompose.pl confident.SE.lst >SE.inc.splicesite 2>SE.exc.splicesite"
        subprocess.call(cmd, shell=True)
    elif asType == "A3SS":
        cmd = "anssDecompose.pl -n 5 confident.A5SS.lst >A5SS.inc.splicesite 2>A5SS.exc.splicesite"
        subprocess.call(cmd, shell=True)
    elif asType == "A5SS":
        cmd = "anssDecompose.pl -n 3 confident.A3SS.lst >A3SS.inc.splicesite 2>A3SS.exc.splicesite"
        subprocess.call(cmd, shell=True)


def getCnsSite(intronStarts, transIntronStarts, offset):
    '''
    get consensus intron boundary site between reference and reads info
    :return: count of consensus site num
    '''
    s2, cnsN = 0, 0
    for intronStart1 in intronStarts:
        for i in range(s2, len(transIntronStarts)):
            intronStart2 = transIntronStarts[i]
            if intronStart2 > intronStart1 + offset: break
            if intronStart1 - offset <= intronStart2 and intronStart2 <= intronStart1 + offset:
                cnsN += 1
                s2 += 1
    return cnsN

def getConsensusIntronNfromAS(exonStarts1, exonEnds1, exonStarts2, exonEnds2, offset):
    '''
    get consensus intron number, i.e. the intron info of reads is identical to the reference
    :return: the count of the consensus introns
    '''
    intronStarts1, intronEnds1 = getIntrons(exonStarts1, exonEnds1)
    intronStarts2, intronEnds2 = getIntrons(exonStarts2, exonEnds2)
    totalCnsN = 0
    for asType in AStypes:
        if asType in ["IR", "SE"]:
            j, consensusN = 0, 0
            for i in range(len(intronStarts1)):
                for k in range(j, len(intronStarts2)):
                    if intronStarts2[k] > intronEnds1[i]: break
                    if intronStarts1[i] - offset <= intronStarts2[k] and intronStarts2[k] <= intronStarts1[i] + offset and \
                            intronEnds1[i] - offset <= intronEnds2[k] and intronEnds2[k] <= intronEnds1[i] + offset:
                        consensusN += 1
                        j += 1
            totalCnsN += consensusN
        elif asType in ["A3SS", "A5SS"]:
            cnsIntronStartN = getCnsSite(intronStarts1, intronStarts2, offset)
            cnsIntronEndN = getCnsSite(intronEnds1, intronEnds2, offset)
            totalCnsN += cnsIntronStartN + cnsIntronEndN
    return totalCnsN

def getAS(annoBedRes, novelBedRes, offset=0, reference=0):
    annoDict, novelDict = {}, {}
    isNovelDict = {}
    for line in annoBedRes:
        record = str(line).strip("\n").split("\t")
        read = Bed12("\t".join(record[:12]))
        trans = ReadLineStruc("\t".join(record[12:]))
        if reference and record[12] != record[-1]: continue
        if read.name not in isNovelDict:
            isNovelDict[read.name] = {"read": read, "isNovel": 1}
        transStarts, transEnds = trans.exonStarts, trans.exonEnds
        readStarts, readEnds, blockCount = read.exonStarts, read.exonEnds, read.blockCount
        # if blockCount < 2: continue
        consensusIntronN = getConsensusIntronNfromAS(readStarts, readEnds, transStarts, transEnds, offset)
        if consensusIntronN >= 1:
            transName, geneName = trans.name, trans.geneName
            if geneName not in annoDict:
                gene2reads = Gene2Reads(geneName)
                gene2reads.update(read)
                gene2reads.trans = {transName: trans}
                annoDict[geneName] = gene2reads
            else:
                gene2reads = annoDict[geneName]
                # if read.name not in gene2reads.readNames:
                gene2reads.update(read)
                gene2reads.trans.update({transName: trans})
                annoDict[geneName] = gene2reads
            isNovelDict[read.name]["isNovel"] = 0
        else:
            if blockCount == 1:
                transName, geneName = trans.name, trans.geneName
                if isOverlap((read.chromStart, read.chromEnd), (trans.chromStart, trans.chromEnd)):
                    overlap = getOverlapOfTuple([(read.chromStart, read.chromEnd)], [(trans.chromStart, trans.chromEnd)])
                    sumOverlap = sum([x[1] - x[0]for x in overlap])
                    if sumOverlap/float(read.chromEnd-read.chromStart) >= 0.5:
                        if geneName not in annoDict:
                            gene2reads = Gene2Reads(geneName)
                            gene2reads.update(read)
                            gene2reads.trans = {transName: trans}
                            annoDict[geneName] = gene2reads
                        else:
                            gene2reads = annoDict[geneName]
                            gene2reads.update(read)
                            gene2reads.trans.update({transName: trans})
                            annoDict[geneName] = gene2reads
                        isNovelDict[read.name]["isNovel"] = 0

    for line in novelBedRes:
        read = Bed12(str(line))
        if read.chrom not in novelDict:
            novelDict[read.chrom] = {read.strand: [read]}
        elif read.strand not in novelDict[read.chrom]:
            novelDict[read.chrom][read.strand] = [read]
        else:
            novelDict[read.chrom][read.strand].append(read)

    for i in isNovelDict:
        if isNovelDict[i]["isNovel"]:
            read = isNovelDict[i]["read"]
            if read.chrom not in novelDict:
                novelDict[read.chrom] = {read.strand: [read]}
            elif read.strand not in novelDict[read.chrom]:
                novelDict[read.chrom][read.strand] = [read]
            else:
                novelDict[read.chrom][read.strand].append(read)
    return annoDict, novelDict

def filterIrByJunc(irBed, junctionBed, confidentIrBed):
    juncDict = {}
    with open(junctionBed) as f:
        for line in f.readlines():
            juncDict.update({Junction(line.strip("\n")).jPos: ""})

    out = open(confidentIrBed, "w")
    with open(irBed) as f:
        for line in f.readlines():
            infoList = line.strip("\n").split("\t")
            juncPos = "{}:{}-{}".format(infoList[0], infoList[1], infoList[2])
            if juncPos in juncDict:
                print >> out, line.strip("\n")
    out.close()

def getPaCluster(readsBed=None, tofuGroup=None, filterByCount=0, threads=None, paClusterOut=None, paDist=20, windowSize=5, rpkmPAC=0, confidentPa=None):
    gene2reads = {}
    readsDict = BedFile(readsBed, type="bed12+").reads
    allReadCount = len(readsDict)
    with open(tofuGroup) as f:
        for i in f.readlines():
            infoList = i.strip("\n").split("\t")
            gene = ".".join(infoList[0].split(".")[:2])
            if gene not in gene2reads:
                gene2reads[gene] = {"allReads": []}
            gene2reads[gene]["allReads"].extend(infoList[1].split(","))
    confidentPaDict = {}
    if confidentPa and validateFile(confidentPa):
        with open(confidentPa) as f:
            for i in f.readlines():
                infoList = i.strip("\n").split("\t")
                for x in xrange(max(0, int(infoList[2])-paDist-1), int(infoList[2])+paDist):
                    paSite = "{}_{}".format(infoList[0], x)
                    confidentPaDict.update({paSite: ""})
    outHandle = open(paClusterOut, "w")
    for z in gene2reads:
        if filterByCount:
            if len(gene2reads[z]["allReads"]) < filterByCount:
                continue
        readsList = gene2reads[z]["allReads"]
        readsBedList = [readsDict[r] for r in readsList if r in readsDict]
        if len(readsBedList) == 0: continue
        chroms = [r.chrom for r in readsBedList]
        mostChrom = Counter(chroms).most_common(1)[0][0]
        readsBedList = [r for r in readsBedList if r.chrom == mostChrom]
        paCluster_test(readsBedList, distance=paDist, windowSize=windowSize, outHandle=outHandle,
                       allReadCount=allReadCount, paSup=filterByCount, rpkmPAC=rpkmPAC, confidentPaDict=confidentPaDict)
        # paCluster(readsBedList, outHandle=outHandle, distance=paDist)
    outHandle.close()


def findIR(gene2ReadsDict, outAS=None, out=None, anno=True, offset=0, isoform2reads=None):
    for gName in gene2ReadsDict:
        readsDict = gene2ReadsDict[gName].reads
        chrom = gene2ReadsDict[gName].chrom
        strand = gene2ReadsDict[gName].strand
        rNames = readsDict.keys()
        if len(rNames) < 2: continue
        irDict = {}
        for rName1 in rNames:
            exonStarts, exonEnds = readsDict[rName1].exonStarts, readsDict[rName1].exonEnds
            for exon1 in range(len(exonStarts) - 1):
                IR = "%d-%d" % (exonEnds[exon1], exonStarts[exon1 + 1])
                if IR in irDict: continue
                irDict[IR] = {}
                if "spliced" not in irDict[IR]:
                    irDict[IR].__setitem__("spliced", [readsDict[rName1]])
                else:
                    irDict[IR]["spliced"].append(readsDict[rName1])
                for rName2 in rNames:
                    if rName1 == rName2: continue
                    exons2 = readsDict[rName2].exonChain.split(";")
                    for exon2 in range(len(exons2)):
                        exon2Start, exon2End = [int(x) for x in exons2[exon2].split("-")]
                        if exon2Start < exonEnds[exon1] and exonStarts[exon1 + 1] < exon2End \
                                and abs(exon2Start - exonEnds[exon1]) > offset \
                                and abs(exonStarts[exon1 + 1] - exon2End) > offset:
                            if "retention" not in irDict[IR]:
                                irDict[IR].__setitem__("retention", [readsDict[rName2]])
                                break
                            else:
                                irDict[IR]["retention"].append(readsDict[rName2])
                        if exon2End == exonEnds[exon1]:
                            if exon2 + 1 >= len(exons2): break
                            exon2NStart, exon2NEnd = [int(x) for x in exons2[exon2 + 1].split("-")]
                            if exon2NStart == exonStarts[exon1 + 1]:
                                irDict[IR]["spliced"].append(readsDict[rName2])
                        if exon2Start > exonEnds[exon1 + 1]: break
        newIrDict = {}
        for ir in irDict:
            if "retention" in irDict[ir]:
                newIrDict[ir] = irDict[ir]
                if outAS:
                    irStart, irEnd = [int(x) for x in ir.split("-")]
                    if anno:
                        transDict = gene2ReadsDict[gName].trans
                        overlapWithGene = 0
                        for tran in transDict:
                            if irStart < transDict[tran].chromEnd and irEnd > transDict[tran].chromStart:
                                overlapWithGene = 1
                                break
                        if overlapWithGene == 1:
                            retentionReads = [x.name for x in irDict[ir]["retention"]]
                            splicedReads = [x.name for x in irDict[ir]["spliced"]]
                            psi = float(len(retentionReads))/(len(retentionReads)+len(splicedReads))*1000
                            if isoform2reads:
                                rawRetentionReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in retentionReads]))
                                rawSplicedReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in splicedReads]))
                                psi = float(len(rawRetentionReads))/(len(rawRetentionReads)+len(rawSplicedReads))*1000
                            print >> out, "\t".join(map(str, [chrom, irStart, irEnd, gName+":"+ir, psi, strand, gName, ",".join(retentionReads), len(retentionReads), ",".join(splicedReads), len(splicedReads)]))
                    else:
                        retentionReads = [x.name for x in irDict[ir]["retention"]]
                        splicedReads = [x.name for x in irDict[ir]["spliced"]]
                        psi = float(len(retentionReads)) / (len(retentionReads) + len(splicedReads)) * 1000
                        if isoform2reads:
                            rawRetentionReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in retentionReads]))
                            rawSplicedReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in splicedReads]))
                            psi = float(len(rawRetentionReads))/(len(rawRetentionReads)+len(rawSplicedReads))*1000
                        print >> out, "\t".join(map(str, [chrom, irStart, irEnd, gName + ":" + ir, psi, strand, gName, ",".join(retentionReads), len(retentionReads), ",".join(splicedReads), len(splicedReads)]))
        gene2ReadsDict[gName].asDict.update({"IR": newIrDict})


def findSE(gene2ReadsDict, outAS=None, out=None, anno=True, offset=0, isoform2reads=None):
    for gName in gene2ReadsDict:
        readsDict = gene2ReadsDict[gName].reads
        chrom = gene2ReadsDict[gName].chrom
        strand = gene2ReadsDict[gName].strand
        rNames = readsDict.keys()
        if len(rNames) < 2: continue
        exonDict = {}
        for rName1 in rNames:
            exons = readsDict[rName1].exonChain.split(";")
            for l in range(len(exons) - 2):
                for r in range(l + 2, len(exons)):
                    lExonEnd = int(exons[l].split("-")[1])
                    rExonStart = int(exons[r].split("-")[0])
                    SEs = ";".join(exons[l + 1:r])
                    seChain = "%d@%s@%d" % (lExonEnd, SEs, rExonStart)
                    if seChain in exonDict: continue
                    exonDict[seChain] = {}
                    if "keep" not in exonDict[seChain]:
                        exonDict[seChain].__setitem__("keep", [readsDict[rName1]])
                    else:
                        exonDict[seChain]["keep"].append(readsDict[rName1])
                    for rName2 in rNames:
                        if rName2 == rName1: continue
                        skipPat = "-%d;%d-" % (lExonEnd, rExonStart)
                        keepPat = "-%d;%s;%d-" % (lExonEnd, SEs, rExonStart)
                        if re.search(skipPat, readsDict[rName2].exonChain):
                            if "skip" not in exonDict[seChain]:
                                exonDict[seChain].__setitem__("skip", [readsDict[rName2]])
                            else:
                                exonDict[seChain]["skip"].append(readsDict[rName2])
                        elif re.search(keepPat, readsDict[rName2].exonChain):
                            exonDict[seChain]["keep"].append(readsDict[rName2])
        newExonDict = {}
        for seChain1 in exonDict.keys():
            if "skip" in exonDict[seChain1]:
                newExonDict[seChain1] = exonDict[seChain1]
                if outAS:
                    keepReads = [x.name for x in exonDict[seChain1]["keep"]]
                    skipReads = [x.name for x in exonDict[seChain1]["skip"]]
                    keepReadsCount = len(keepReads)
                    skipReadsCount = len(skipReads)
                    lSpliceSite, SEs1, rSpliceSite = seChain1.split("@")
                    SElist = SEs1.split(";")
                    starts, ends = [], []
                    for exon in SElist:
                        exonStart, exonEnd = listStr2Int(exon.split("-"))
                        starts.append(exonStart)
                        ends.append(exonEnd)
                    if anno:
                        overlapWithGene = 0
                        transDict = gene2ReadsDict[gName].trans
                        for tran in transDict:
                            if starts[0] < transDict[tran].chromEnd and ends[-1] > transDict[tran].chromStart:
                                overlapWithGene = 1
                                break
                        if overlapWithGene == 1:
                            blockSizes = ",".join([str(x) for x in getSizes(starts, ends)])
                            blockRelStarts = ",".join([str(x) for x in getRelStarts(starts)])
                            psi = float(keepReadsCount)/(keepReadsCount + skipReadsCount) * 1000
                            if isoform2reads:
                                rawKeepReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in keepReads]))
                                rawSkipReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in skipReads]))
                                psi = float(len(rawKeepReads)) / (len(rawKeepReads) + len(rawSkipReads)) * 1000
                            print >> out, "\t".join(map(str, [chrom, str(starts[0]), str(ends[-1]),
                                                              "%s:%s" % (gName, seChain1), psi, strand, starts[0],
                                                              ends[-1], "0,0,0", len(starts), blockSizes,
                                                              blockRelStarts, gName, lSpliceSite, rSpliceSite,
                                                              ",".join(keepReads), len(keepReads), ",".join(skipReads),
                                                              len(skipReads)]))
                    else:
                        blockSizes = ",".join([str(x) for x in getSizes(starts, ends)])
                        blockRelStarts = ",".join([str(x) for x in getRelStarts(starts)])
                        psi = float(keepReadsCount) / (keepReadsCount + skipReadsCount) * 1000
                        if isoform2reads:
                            rawKeepReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in keepReads]))
                            rawSkipReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in skipReads]))
                            psi = float(len(rawKeepReads)) / (len(rawKeepReads) + len(rawSkipReads)) * 1000
                        print >> out, "\t".join(map(str,
                                                    [chrom, str(starts[0]), str(ends[-1]), "%s:%s" % (gName, seChain1),
                                                     psi, strand, starts[0], ends[-1], "0,0,0", len(starts), blockSizes,
                                                     blockRelStarts, gName, lSpliceSite, rSpliceSite,
                                                     ",".join(keepReads), len(keepReads), ",".join(skipReads),
                                                     len(skipReads)]))
        gene2ReadsDict[gName].asDict.update({"SE": newExonDict})


def findA3SS(gene2ReadsDict, outAS=None, out=None, anno=True, offset=0, isoform2reads=None):
    for gName in gene2ReadsDict:
        readsDict = gene2ReadsDict[gName].reads
        chrom = gene2ReadsDict[gName].chrom
        strand = gene2ReadsDict[gName].strand
        rNames = readsDict.keys()
        if len(rNames) < 2: continue
        altDict = {}
        indexStart = 1 if strand == "+" else 0
        for r1 in range(len(rNames) - 1):
            exonsChain1 = gene2ReadsDict[gName].reads[rNames[r1]].exonChain
            exons1 = exonsChain1.split(";")
            indexEnd1 = len(exons1) if strand == "+" else len(exons1) - 1
            for r2 in range(r1 + 1, len(rNames)):
                exonsChain2 = gene2ReadsDict[gName].reads[rNames[r2]].exonChain
                exons2 = exonsChain2.split(";")
                indexEnd2 = len(exons2) if strand == "+" else len(exons2) - 1
                for i in range(indexStart, indexEnd1):
                    exon1Start, exon1End = listStr2Int(exons1[i].split("-"))
                    for j in range(indexStart, indexEnd2):
                        exon2Start, exon2End = listStr2Int(exons2[j].split("-"))
                        if exon1Start < exon2End and exon1End > exon2Start:
                            if strand == "-":
                                if exon1End < exon2End and exon2End < int(exons1[i + 1].split("-")[0]) \
                                    and abs(exon1End - exon2End) > offset \
                                    and abs(exon2End - int(exons1[i + 1].split("-")[0])) > offset:
                                    exonBoundChain = "%d-%d" % (exon1End, exon2End)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (exon1End, int(exons1[i + 1].split("-")[0]))})
                                    altDict[exonBoundChain].update({"incJunc": (exon2End, int(exons2[j + 1].split("-")[0]))})
                                elif exon1End > exon2End and exon1End < int(exons2[j + 1].split("-")[0]) \
                                    and abs(exon1End - exon2End) > offset \
                                    and abs(exon1End - int(exons2[j + 1].split("-")[0])) > offset:
                                    exonBoundChain = "%d-%d" % (exon2End, exon1End)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (exon2End, int(exons2[j + 1].split("-")[0]))})
                                    altDict[exonBoundChain].update({"incJunc": (exon1End, int(exons1[i + 1].split("-")[0]))})
                            else:
                                if exon1Start < exon2Start and exon1Start > int(exons2[j - 1].split("-")[1]) \
                                    and abs(exon1Start - exon2Start) > offset \
                                    and abs(exon1Start - int(exons2[j - 1].split("-")[1])) > offset:
                                    exonBoundChain = "%d-%d" % (exon1Start, exon2Start)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (int(exons2[j - 1].split("-")[1]), exon2Start)})
                                    altDict[exonBoundChain].update({"incJunc": (int(exons1[i - 1].split("-")[1]), exon1Start)})
                                elif exon1Start > exon2Start and exon2Start > int(exons1[i - 1].split("-")[1]) \
                                    and abs(exon1Start - exon2Start) > offset \
                                    and abs(exon2Start - int(exons1[i - 1].split("-")[1])) > offset:
                                    exonBoundChain = "%d-%d" % (exon2Start, exon1Start)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (int(exons1[i - 1].split("-")[1]), exon1Start)})
                                    altDict[exonBoundChain].update({"incJunc": (int(exons2[j - 1].split("-")[1]), exon2Start)})
                        if exon2Start > exon1End: break
        for alt in altDict:
            altStart, altEnd = alt.split("-")
            altDict[alt]["inc"] = list(altDict[alt]["inc"])
            altDict[alt]["exc"] = list(altDict[alt]["exc"])
            if outAS:
                incReads = [x.name for x in altDict[alt]["inc"]]
                excReads = [x.name for x in altDict[alt]["exc"]]
                incJunc = altDict[alt]["incJunc"]
                excJunc = altDict[alt]["excJunc"]
                incReadsCount, excReadsCount = len(incReads), len(excReads)
                psi = float(incReadsCount)/(incReadsCount + excReadsCount) * 1000
                if isoform2reads:
                    rawIncReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in incReads]))
                    rawExcReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in excReads]))
                    psi = float(len(rawIncReads)) / (len(rawIncReads) + len(rawExcReads)) * 1000
                print >>out, "\t".join(map(str, [chrom, str(altStart), str(altEnd), \
                                          "%s:%s" % (gName, alt), str(psi), strand, gName, ",".join(incReads), \
                                          str(incReadsCount), ",".join(excReads), str(excReadsCount), \
                                          "inc:{}-{}".format(incJunc[0], incJunc[1]), \
                                          "exc:{}-{}".format(excJunc[0], excJunc[1])]))

        gene2ReadsDict[gName].asDict.update({"A3SS": altDict})


def findA5SS(gene2ReadsDict, outAS=None, out=None, anno=True, offset=0, isoform2reads=None):
    for gName in gene2ReadsDict:
        readsDict = gene2ReadsDict[gName].reads
        chrom = gene2ReadsDict[gName].chrom
        strand = gene2ReadsDict[gName].strand
        rNames = readsDict.keys()
        if len(rNames) < 2: continue
        altDict = {}
        indexStart = 0 if strand == "+" else 1
        for r1 in range(len(rNames) - 1):
            exonsChain1 = gene2ReadsDict[gName].reads[rNames[r1]].exonChain
            exons1 = exonsChain1.split(";")
            indexEnd1 = len(exons1) - 1 if strand == "+" else len(exons1)
            for r2 in range(r1 + 1, len(rNames)):
                exonsChain2 = gene2ReadsDict[gName].reads[rNames[r2]].exonChain
                exons2 = exonsChain2.split(";")
                indexEnd2 = len(exons2) - 1 if strand == "+" else len(exons2)
                for i in range(indexStart, indexEnd1):
                    exon1Start, exon1End = listStr2Int(exons1[i].split("-"))
                    for j in range(indexStart, indexEnd2):
                        exon2Start, exon2End = listStr2Int(exons2[j].split("-"))
                        if exon1Start < exon2End and exon1End > exon2Start:
                            if strand == "+":
                                if exon1End < exon2End and exon2End < int(exons1[i + 1].split("-")[0]) \
                                    and abs(exon1End - exon2End) > offset \
                                    and abs(exon2End - int(exons1[i + 1].split("-")[0])) > offset:
                                    exonBoundChain = "%d-%d" % (exon1End, exon2End)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (exon1End, int(exons1[i + 1].split("-")[0]))})
                                    altDict[exonBoundChain].update({"incJunc": (exon2End, int(exons2[j + 1].split("-")[0]))})
                                elif exon1End > exon2End and exon1End < int(exons2[j + 1].split("-")[0]) \
                                    and abs(exon1End - exon2End) > offset \
                                    and abs(exon1End - int(exons2[j + 1].split("-")[0])) > offset:
                                    exonBoundChain = "%d-%d" % (exon2End, exon1End)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (exon2End, int(exons2[j + 1].split("-")[0]))})
                                    altDict[exonBoundChain].update({"incJunc": (exon1End, int(exons1[i + 1].split("-")[0]))})
                            else:
                                if exon1Start < exon2Start and exon1Start > int(exons2[j - 1].split("-")[1]) \
                                    and abs(exon1Start - exon2Start) > offset \
                                    and abs(exon1Start - int(exons2[j - 1].split("-")[1])) > offset:
                                    exonBoundChain = "%d-%d" % (exon1Start, exon2Start)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (int(exons2[j - 1].split("-")[1]), exon2Start)})
                                    altDict[exonBoundChain].update({"incJunc": (int(exons1[i - 1].split("-")[1]), exon1Start)})
                                elif exon1Start > exon2Start and exon2Start > int(exons1[i - 1].split("-")[1]) \
                                    and abs(exon1Start - exon2Start) > offset \
                                    and abs(exon2Start - int(exons1[i - 1].split("-")[1])) > offset:
                                    exonBoundChain = "%d-%d" % (exon2Start, exon1Start)
                                    if exonBoundChain not in altDict:
                                        altDict[exonBoundChain] = {"inc": set(), "exc": set()}
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    else:
                                        altDict[exonBoundChain]["exc"].add(readsDict[rNames[r1]])
                                        altDict[exonBoundChain]["inc"].add(readsDict[rNames[r2]])
                                    altDict[exonBoundChain].update({"excJunc": (int(exons1[i - 1].split("-")[1]), exon1Start)})
                                    altDict[exonBoundChain].update({"incJunc": (int(exons2[j - 1].split("-")[1]), exon2Start)})
                        if exon2Start > exon1End: break
        for alt in altDict:
            altStart, altEnd = alt.split("-")
            altDict[alt]["inc"] = list(altDict[alt]["inc"])
            altDict[alt]["exc"] = list(altDict[alt]["exc"])
            incJunc = altDict[alt]["incJunc"]
            excJunc = altDict[alt]["excJunc"]
            if outAS:
                incReads = [x.name for x in altDict[alt]["inc"]]
                excReads = [x.name for x in altDict[alt]["exc"]]
                incReadsCount, excReadsCount = len(incReads), len(excReads)
                psi = float(incReadsCount)/(incReadsCount + excReadsCount) * 1000
                if isoform2reads:
                    rawIncReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in incReads]))
                    rawExcReads = list(itertools.chain.from_iterable([isoform2reads[x] for x in excReads]))
                    psi = float(len(rawIncReads)) / (len(rawIncReads) + len(rawExcReads)) * 1000
                print >>out, "\t".join(map(str, [chrom, str(altStart), str(altEnd), \
                                          "%s:%s" % (gName, alt), str(psi), strand, gName, ",".join(incReads), \
                                          str(incReadsCount), ",".join(excReads), str(excReadsCount), \
                                          "inc:{}-{}".format(incJunc[0], incJunc[1]), \
                                          "exc:{}-{}".format(excJunc[0], excJunc[1])]))
        gene2ReadsDict[gName].asDict.update({"A5SS": altDict})


def findAS(gene2ReadsDict, outASType=None, anno=True, out=None, isoform2reads=None):
    findASType = {"IR": findIR, "SE": findSE, "A3SS": findA3SS, "A5SS": findA5SS}
    if anno:
        if outASType:
            if outASType.upper() not in findASType:
                raise Exception("You should input the right AS type!")
            else:
                findASType[outASType](gene2ReadsDict, outASType, out, isoform2reads=isoform2reads)
        else:
            for asType in findASType:
                findASType[asType](gene2ReadsDict, isoform2reads=isoform2reads)
    else:
        newGene2ReadsDict = {}
        for myChr, myValue in gene2ReadsDict.iteritems():
            for myStrand in myValue:
                sortedStrandV = sorted(myValue[myStrand], key=lambda x: x.chromStart)
                count = 1
                fakeGeneName = "%s:%s:%s_%d" % (myChr, myStrand, "Novel", count)
                gene2reads = Gene2Reads(fakeGeneName)
                gene2reads.update(sortedStrandV[0])
                clusterEnd = sortedStrandV[0].chromEnd
                for i in range(1, len(sortedStrandV)):
                    myStart, myEnd = sortedStrandV[i].chromStart, sortedStrandV[i].chromEnd
                    if myStart < clusterEnd:
                        gene2reads.update(sortedStrandV[i])
                        if myEnd > clusterEnd:
                            clusterEnd = myEnd
                    else:
                        newGene2ReadsDict[fakeGeneName] = gene2reads
                        count += 1
                        fakeGeneName = "%s:%s:%s_%d" % (myChr, myStrand, "Novel", count)
                        gene2reads = Gene2Reads(fakeGeneName)
                        gene2reads.update(sortedStrandV[i])
                        clusterEnd = sortedStrandV[i].chromEnd
                newGene2ReadsDict[fakeGeneName] = gene2reads
        if outASType:
            if outASType.upper() not in findASType:
                raise Exception("You should input the right AS type!")
            else:
                findASType[outASType](newGene2ReadsDict, outASType, out, isoform2reads=isoform2reads, anno=False)
        else:
            for asType in findASType:
                findASType[asType](newGene2ReadsDict, isoform2reads=isoform2reads)


def findASmain(asType="IR", annoDict=None, novelDict=None, outFile=None, isoform2reads=None):
    out = open(outFile, "w")
    findAS(annoDict, outASType=asType, anno=True, out=out, isoform2reads=isoform2reads)
    findAS(novelDict, outASType=asType, anno=False, out=out, isoform2reads=isoform2reads)
    out.close()

def find_refs(chrom, strand, dn, ac_i, ac_o, refDct, dnpos2count):
    "return a list of ref matching input situation"
    if chrom not in refDct:
        return []

    refLst = refDct[chrom]
    refs = []
    left = min(dn, ac_o)
    right = max(dn, ac_o)
    for ref in refLst:
        if ref.strand != strand:
            continue
        elif ref.exonStarts[0] >= right or ref.exonEnds[-1] <= left:
            continue
        else:
            if strand == "+":
                if (dn in ref.exonEnds and ac_i in ref.exonStarts and ac_o in ref.exonStarts):
                    # refs.append(ref)
                    ac_o_index = ref.exonStarts.index(ac_o)
                    dnPos = "%s:%d:%s" % (chrom, ref.exonEnds[ac_o_index - 1], strand)
                    if dnPos in dnpos2count:
                        refs.append(ref)
            else:
                if (dn in ref.exonStarts and ac_i in ref.exonEnds and ac_o in ref.exonEnds):
                    # refs.append(ref)
                    ac_o_index = ref.exonEnds.index(ac_o)
                    dnPos = "%s:%d:%s" % (chrom, ref.exonEnds[ac_o_index - 1], strand)
                    if dnPos in dnpos2count:
                        refs.append(ref)
    return refs

def motifAroundPA(bed6plus=None, up1=100, down1=100, up2=100, down2=100, refFasta=None, chrLenFile=None):
    singleNucleotideMotif = ["A", "T", "C", "G"]
    sixNucleotideMotif = ["AATAAA", "AAATAA", "ATAAAA", "ATTAAA", "ATAAAT", "TAATAA",
                          "ATAAAG", "AAAATA", "CAATAA", "ATAAAC", "AAAAAA", "AAAAAG"]
    chrLenDict = {}
    with open(chrLenFile) as f:
        for i in f.readlines():
            infoList = i.strip("\n").split("\t")
            chrLenDict[infoList[0]] = int(infoList[1])
    with open(bed6plus) as f:
        singleNucleotideUpBedList = []
        singleNucleotideDownBedList = []
        sixNucleotideUpBedList = []
        sixNucleotideDownBedList = []
        for i in f.readlines():
            bedObj = Bed6Plus(i)
            chrom, start, end, strand = bedObj.chrom, bedObj.chromStart, bedObj.chromEnd, bedObj.strand
            name = bedObj.name
            if strand == "+":
                if start > up1 and end + down1 < chrLenDict[chrom]:
                    singleNucleotideUpBedList.append(" ".join(map(str, [chrom, start - up1, start, name, ".", strand])))
                    singleNucleotideDownBedList.append(" ".join(map(str, [chrom, end, end + down1, name, ".", strand])))
                if start > up2 and end + down2 + 5 < chrLenDict[chrom]:
                    sixNucleotideUpBedList.append(" ".join(map(str, [chrom, start - up2, start + 5, name, ".", strand])))
                    sixNucleotideDownBedList.append(" ".join(map(str, [chrom, end, end + down2 + 5, name, ".", strand])))
            else:
                if start > down1 and end + up1 < chrLenDict[chrom]:
                    singleNucleotideUpBedList.append(" ".join(map(str, [chrom, end, end + up1, name, ".", strand])))
                    downLeft = start - down1 - 1 if start - down1 - 1 > 0 else 0
                    singleNucleotideDownBedList.append(" ".join(map(str, [chrom, downLeft, start-1, name, ".", strand])))
                if start > down2 and end + up2 + 5 < chrLenDict[chrom]:
                    sixNucleotideUpBedList.append(" ".join(map(str, [chrom, end, end + up2 + 5, name, ".", strand])))
                    downLeft = start - down2 - 5 if start - down2 - 5 > 0 else 0
                    sixNucleotideDownBedList.append(" ".join(map(str, [chrom, downLeft, start, name, ".", strand])))
        singleNucleotideUpBedObj = pybedtools.BedTool("\n".join(singleNucleotideUpBedList), from_string=True)
        singleNucleotideDownBedObj = pybedtools.BedTool("\n".join(singleNucleotideDownBedList), from_string=True)
        sixNucleotideUpBedObj = pybedtools.BedTool("\n".join(sixNucleotideUpBedList), from_string=True)
        sixNucleotideDownBedObj = pybedtools.BedTool("\n".join(sixNucleotideDownBedList), from_string=True)

        singleNucleotideUpBedFastaRes = singleNucleotideUpBedObj.sequence(refFasta, name=True, tab=True, s=True)
        singleNucleotideDownBedFastaRes = singleNucleotideDownBedObj.sequence(refFasta, name=True, tab=True, s=True)
        sixNucleotideUpBedFastaRes = sixNucleotideUpBedObj.sequence(refFasta, name=True, tab=True, s=True)
        sixNucleotideDownBedFastaRes = sixNucleotideDownBedObj.sequence(refFasta, name=True, tab=True, s=True)

        singleNucleotideUpBedFastaDict = {}
        singleNucleotideDownBedFastaDict = {}
        sixNucleotideUpBedFastaDict = {}
        sixNucleotideDownBedFastaDict = {}
        for res in str(open(singleNucleotideUpBedFastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = res.split("\t")
            singleNucleotideUpBedFastaDict[infoList[0]] = [infoList[1].upper()[i:i+1] for i in range(0, len(infoList[1]), 1)]
        for res in str(open(singleNucleotideDownBedFastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = res.split("\t")
            singleNucleotideDownBedFastaDict[infoList[0]] = [infoList[1].upper()[i:i + 1] for i in range(0, len(infoList[1]), 1)]
        for res in str(open(sixNucleotideUpBedFastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = res.split("\t")
            sixNucleotideUpBedFastaDict[infoList[0]] = [infoList[1].upper()[i:i + 6] for i in range(0, len(infoList[1]) - 5, 1)]
        for res in str(open(sixNucleotideDownBedFastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = res.split("\t")
            sixNucleotideDownBedFastaDict[infoList[0]] = [infoList[1].upper()[i:i + 6] for i in range(0, len(infoList[1]) - 5, 1)]
        singleNucleotideUpDf = pd.DataFrame.from_dict(singleNucleotideUpBedFastaDict, orient="index")
        singleNucleotideDownDf = pd.DataFrame.from_dict(singleNucleotideDownBedFastaDict, orient="index")
        sixNucleotideUpDf = pd.DataFrame.from_dict(sixNucleotideUpBedFastaDict, orient="index")
        sixNucleotideDownDf = pd.DataFrame.from_dict(sixNucleotideDownBedFastaDict, orient="index")

        for i in singleNucleotideMotif:
            singleNucleotideOut = open(i+".nucleotide", "w")
            singleNucleotideUpDf1 = singleNucleotideUpDf == i
            upPercent = singleNucleotideUpDf1.sum() / float(len(singleNucleotideUpDf1))
            for j in range(len(upPercent)):
                print >>singleNucleotideOut, "\t".join(map(str, [j - up1, upPercent[j]]))

            singleNucleotideDownDf1 = singleNucleotideDownDf == i
            downPercent = singleNucleotideDownDf1.sum() / float(len(singleNucleotideDownDf1))
            for j in range(len(downPercent)):
                print >>singleNucleotideOut, "\t".join(map(str, [j + 1, downPercent[j]]))
            singleNucleotideOut.close()

        for i in sixNucleotideMotif:
            sixNucleotideOut = open(i + ".PAS", "w")
            sixNucleotideUpDf1 = sixNucleotideUpDf == i
            upPercent = sixNucleotideUpDf1.sum() / float(len(sixNucleotideUpDf1))
            for j in range(len(upPercent)):
                print >>sixNucleotideOut, "\t".join(map(str, [j - up2, upPercent[j]]))

            sixNucleotideDownDf1 = sixNucleotideDownDf == i
            downPercent = sixNucleotideDownDf1.sum() / float(len(sixNucleotideDownDf1))
            for j in range(len(downPercent)):
                print >>sixNucleotideOut, "\t".join(map(str, [j + 1, downPercent[j]]))
            sixNucleotideOut.close()

def getPAC(depth, distance=20, windowSize=2, paSup=5, rpkmPAC=0, allReadCount=1000000, effLen=1):
    N = len(depth)
    # peaks = []
    # counts = []
    currPeaks = np.zeros(len(depth))
    for i in xrange(N):
        if np.sum(depth[max(0, i - windowSize - 1):min(N, i + windowSize)]) >= paSup:
            currPeaks[i] = depth[i] * 2 + np.mean(depth[max(0, i - windowSize - 1):min(N, i + windowSize)])
            # currPeaks[i] = sum(depth[max(0, i - windowSize - 1):min(N, i + windowSize)])
    currPeaksBak = copy.copy(currPeaks)
    pacDict = {}
    count = 0
    while np.max(currPeaks):
        cp = np.argmax(currPeaks)
        overlapFlag = 0
        maxDiff = 1000000
        closestPAC = ""
        for pac in pacDict:
            if isOverlap((cp-distance-1, cp+distance), (min(pacDict[pac]), max(pacDict[pac]))):
                overlapFlag = 1
                diff2pac = min(abs(cp - min(pacDict[pac])), abs(cp - max(pacDict[pac])))
                if diff2pac < maxDiff:
                    maxDiff = diff2pac
                    closestPAC = pac
        if overlapFlag:
            pacDict[closestPAC].append(cp)
        else:
            count += 1
            pacName = "PAC_{}".format(count)
            pacDict[pacName] = [cp]
        currPeaks[cp] = 0

    newPacDict = {pacDict.keys()[0]: copy.copy(pacDict[pacDict.keys()[0]])}
    for pac1 in pacDict.keys()[1:]:
        pac1Start = min(pacDict[pac1])
        pac1End = max(pacDict[pac1])
        for pac2 in newPacDict:
            pac2Start = min(newPacDict[pac2])
            pac2End = max(newPacDict[pac2])
            if isOverlap((pac1Start-distance-1, pac1End+distance), (pac2Start, pac2End)):
                newPacDict[pac2].extend(pacDict[pac1])
                break
        else:
            newPacDict[pac1] = copy.copy(pacDict[pac1])

    finalPeak2Count = []
    for pac in newPacDict:
        peak = newPacDict[pac][int(np.argmax(currPeaksBak[newPacDict[pac]]))]
        count = sum(depth[newPacDict[pac]])
        if rpkmPAC:
            rpkm = (count * 1000000) / float(allReadCount*effLen)
            if rpkm >= rpkmPAC:
                finalPeak2Count.append((peak, count, newPacDict[pac]))
        else:
            finalPeak2Count.append((peak, count, newPacDict[pac]))
    if finalPeak2Count:
        finalPeak2Count = sorted(finalPeak2Count, key=lambda pair: pair[1], reverse=True)
    return finalPeak2Count

    # while True:
    #     currPeaks = np.zeros(len(depth))
    #     for i in xrange(N):
    #         for c in peaks:
    #             if i <= c and c - i + 1 < distance or \
    #                     i >= c and i - c + 1 < distance:
    #                 break
    #         else:
    #             if np.sum(depth[max(0, i - windowSize - 1):min(N, i + windowSize)]) >= paSup:
    #                 currPeaks[i] = sum(depth[max(0, i - windowSize - 1):min(N, i + windowSize)])
    #     if np.max(currPeaks) == 0:
    #         break
    #     cp = np.argmax(currPeaks)
    #     if cp not in peaks:
    #         peaks.append(cp)
    #         counts.append(sum(depth[max(0, cp - windowSize - 1):min(N, cp + windowSize)]))
    # peak2count = zip(peaks, counts)
    # finalPeak2count = []
    # for peak, count in peak2count:
    #     tpm = (count * 1000000) / allReadCount
    #     if tpm >= tpmPAC:
    #         finalPeak2count.append((peak, count))
    # finalPeak2count = sorted(finalPeak2count, key=lambda pair: pair[0])
    # return finalPeak2count

# def getPaPeaks(depth, distance=20, windowSize=3, paSup=5, rpkmPAC=10, allReadCount=1000000):
#     N = len(depth)
#     peaks = []
#     counts = []
#     while True:
#         currPeaks = np.zeros(len(depth))
#         for i in xrange(N):
#             for c in peaks:
#                 if i <= c and c - i + 1 < distance or \
#                         i >= c and i - c + 1 < distance:
#                     break
#             else:
#                 if np.sum(depth[max(0, i - windowSize - 1):min(N, i + windowSize)]) >= paSup:
#                     currPeaks[i] = depth[i] * 2 + np.median(depth[max(0, i - windowSize - 1):min(N, i + windowSize)])
#         if np.max(currPeaks) == 0:
#             break
#         cp = np.argmax(currPeaks)
#         if cp not in peaks:
#             peaks.append(cp)
#             counts.append(sum(depth[max(0, cp - windowSize - 1):min(N, cp + windowSize)]))
#     peak2count = zip(peaks, counts)
#     finalPeak2count = []
#     for peak, count in peak2count:
#         tpm = (count * 1000000)/allReadCount
#         if tpm >= tpmPAC:
#             finalPeak2count.append((peak, count))
#     finalPeak2count = sorted(finalPeak2count, key=lambda pair: pair[0])
#     return finalPeak2count

def paCluster_test(readsBedList, distance=20, windowSize=3, outHandle=None, allReadCount=1000000, paSup=5, rpkmPAC=0, confidentPaDict=None):
    chroms = [i.chrom for i in readsBedList]
    strands = [i.strand for i in readsBedList]
    refGene = Counter([i.otherList[2] for i in readsBedList]).most_common()[0][0]
    if len(set(strands)) != 1: return
    chrom = list(set(chroms))[0]
    strand = list(set(strands))[0]
    if strand == "+":
        sortedPAs = sorted(readsBedList, key=lambda x: x.chromEnd)
        paRange = [sortedPAs[0].chromEnd, sortedPAs[-1].chromEnd]
        effectiveLength = abs(paRange[0] - paRange[1]) + 1
        depth = np.zeros(paRange[1] - paRange[0] + 1, int)
        depth2reads = {}
        offest = paRange[0]
        for read in sortedPAs:
            depth[read.chromEnd-offest] += 1
            if read.chromEnd-offest not in depth2reads:
                depth2reads[read.chromEnd-offest] = []
            depth2reads[read.chromEnd-offest].append(read.name)
        finalPeak2Count = getPAC(depth, distance=distance, windowSize=windowSize, paSup=paSup, rpkmPAC=rpkmPAC, allReadCount=allReadCount, effLen=effectiveLength)
    else:
        sortedPAs = sorted(readsBedList, key=lambda x: x.chromStart)
        paRange = [sortedPAs[0].chromStart, sortedPAs[-1].chromStart]
        effectiveLength = abs(paRange[0] - paRange[1]) + 1
        depth = np.zeros(paRange[1] - paRange[0] + 1, int)
        depth2reads = {}
        offest = paRange[0]
        for read in sortedPAs:
            depth[read.chromStart-offest] += 1
            if read.chromStart-offest not in depth2reads:
                depth2reads[read.chromStart-offest] = []
            depth2reads[read.chromStart-offest].append(read.name)
        finalPeak2Count = getPAC(depth, distance=distance, windowSize=windowSize, paSup=paSup, rpkmPAC=rpkmPAC, allReadCount=allReadCount, effLen=effectiveLength)
    for peak, count, pac in finalPeak2Count:
        currPaSite = "{}_{}".format(chrom, peak+offest)
        if confidentPaDict:
            if currPaSite not in confidentPaDict:
                annotation = "Known"
            else:
                annotation = "Novel"
        else:
            annotation = "Unknown"
        readNames = list(itertools.chain.from_iterable([depth2reads[x] for x in pac if x in depth2reads]))
        print >> outHandle, "\t".join(map(str, [chrom, offest + min(pac), offest + max(pac), ",".join(readNames),
                                                len(readNames), strand, offest + peak-1, offest + peak, refGene,
                                                annotation]))


def paCluster(readsBedList, distance=20, windowSize=3, manner="mode", outHandle=None, allReadCount=1000000):
    chroms = [i.chrom for i in readsBedList]
    strands = [i.strand for i in readsBedList]
    refGene = Counter([i.otherList[2] for i in readsBedList]).most_common()[0][0]
    if len(set(strands)) != 1: return
    chrom = list(set(chroms))[0]
    strand = list(set(strands))[0]
    if strand == "+":
        sortedPAs = sorted(readsBedList, key=lambda x: x.chromEnd)
        paRangeEnd = sortedPAs[0].chromEnd
        paRangeStart = paRangeEnd - 1
    else:
        sortedPAs = sorted(readsBedList, key=lambda x: x.chromStart)
        paRangeStart = sortedPAs[0].chromStart
        paRangeEnd = paRangeStart + 1
    readNames = [sortedPAs[0].name]
    relPaSites = [1]
    for i in range(1, len(sortedPAs)):
        tmpRead = sortedPAs[i]
        currentPa = tmpRead.chromEnd if strand == "+" else tmpRead.chromStart + 1
        if currentPa - paRangeEnd <= distance:
            paRangeEnd = currentPa
            readNames.append(tmpRead.name)
            relPaSites.append(currentPa - paRangeStart)
        else:
            if strand == "-":
                relPaSites = [paRangeEnd - paRangeStart - i + 1 for i in relPaSites][::-1]
            paCounter = Counter(relPaSites)
            currentCount = reduce(lambda x, y: x + y, [paCounter[z+1] for z in range(windowSize) if z + 1 in paCounter])
            maxCount = currentCount
            maxCountPos = range(windowSize)
            for j in range(2, max(paCounter.keys()) - windowSize + 1):
                currentCount = 0
                tmpPos = []
                for z in range(j, j + windowSize):
                    if z + 1 in paCounter:
                        currentCount += paCounter[z + 1]
                        tmpPos.append(z + 1)
                if currentCount > maxCount:
                    maxCount = currentCount
                    maxCountPos = tmpPos

            maxCountPosSorted = sorted([(x, paCounter[x]) for x in maxCountPos], key=lambda x: (x[1], x[0]), reverse=True)
            mainPaSite = maxCountPosSorted[0][0]
            if strand == "+":
                paSite = paRangeStart + mainPaSite
            else:
                readNames = readNames[::-1]
                paSite = paRangeEnd - mainPaSite + 1
            readCount = len(readNames)
            freq = []
            for tmp in range(max(relPaSites)):
                if tmp + 1 in paCounter:
                    freq.append(round(paCounter[tmp + 1]/float(len(relPaSites)), 2))
                else:
                    freq.append(round(0, 2))
            print >> outHandle, "\t".join(map(str, [chrom, paRangeStart, paRangeEnd, ",".join(readNames), readCount, strand,
                                               paSite - 1, paSite, refGene, ",".join(map(str, relPaSites)), len(paCounter),
                                               round(maxCount / float(readCount), 2), "\t".join(map(str, freq))]))
            paRangeStart = currentPa - 1
            paRangeEnd = currentPa
            readNames = [tmpRead.name]
            relPaSites = [1]

    if strand == "-":
        relPaSites = [paRangeEnd - paRangeStart - i + 1 for i in relPaSites][::-1]
    paCounter = Counter(relPaSites)
    currentCount = reduce(lambda x, y: x + y, [paCounter[z + 1] for z in range(windowSize) if z + 1 in paCounter])
    maxCount = currentCount
    maxCountPos = range(windowSize)
    for j in range(2, max(paCounter.keys()) - windowSize + 1):
        currentCount = 0
        tmpPos = []
        for z in range(j, j + windowSize):
            if z + 1 in paCounter:
                currentCount += paCounter[z + 1]
                tmpPos.append(z + 1)
        if currentCount > maxCount:
            maxCount = currentCount
            maxCountPos = tmpPos

    maxCountPosSorted = sorted([(x, paCounter[x]) for x in maxCountPos], key=lambda x: (x[1], x[0]), reverse=True)
    mainPaSite = maxCountPosSorted[0][0]
    if strand == "+":
        paSite = paRangeStart + mainPaSite
    else:
        readNames = readNames[::-1]
        paSite = paRangeEnd - mainPaSite + 1
    readCount = len(readNames)
    freq = []
    for tmp in range(max(relPaSites)):
        if tmp + 1 in paCounter:
            freq.append(round(paCounter[tmp + 1] / float(len(relPaSites)), 2))
        else:
            freq.append(round(0, 2))
    print >> outHandle, "\t".join(map(str, [chrom, paRangeStart, paRangeEnd, ",".join(readNames), readCount, strand,
                                            paSite - 1, paSite, refGene, ",".join(map(str, relPaSites)), len(paCounter),
                                            round(maxCount / float(readCount), 2), "\t".join(map(str, freq))]))


def se_structure(strand, dn, ac_i, ac_o, ref):
    "return SE events (in SE object) in ref"
    left = min([ac_i, ac_o])
    right = max([ac_i, ac_o])

    bed = Bed12()
    bed.chrom = ref.chrom
    bed.strand = strand
    exSts = []
    exEds = []
    for st, ed in zip(ref.exonStarts, ref.exonEnds):
        if st >= left and ed <= right:
            exSts.append(st)
            exEds.append(ed)
        elif st >= right:
            break
    bed.exonStarts = exSts
    bed.exonEnds = exEds
    bed.chromStart = bed.thickStart = exSts[0]
    bed.chromEnd = bed.thickEnd = exEds[-1]
    bed.blockStarts = getRelStarts(exSts)
    bed.blockSizes = getSizes(exSts, exEds)
    bed.blockCount = len(exSts)

    if strand == "+":
        junc_left = dn
        junc_right = ac_o
    else:
        junc_left = ac_o
        junc_right = dn
    se = SE(bed, junc_left, junc_right)
    return se

def splicesite2seq(refFasta, spliceSite, noFiveEnd=False, noThreeEnd=False, outFile=None):
    donorList, acceptorList = [], []
    exonDist, intronDist = 0, 2
    with open(spliceSite) as f:
        count = 0
        for line in f.readlines():
            infoList = line.strip("\n").split("\t")
            chrom, leftSite, rightSite, strand = infoList[0], infoList[1], infoList[2], infoList[3]
            count += 1
            juncName = "junction_" + str(count)
            if infoList[3] == "+":
                if not noFiveEnd:
                    leftSite = int(leftSite)
                    donorBed = "\t".join(map(str, [chrom, leftSite - exonDist, leftSite + intronDist, juncName, ".", strand]))
                    donorList.append(donorBed)
                if not noThreeEnd:
                    rightSite = int(rightSite)
                    acceptorBed = "\t".join(map(str, [chrom, rightSite - intronDist, rightSite + exonDist, juncName, ".", strand]))
                    acceptorList.append(acceptorBed)
            else:
                if not noFiveEnd:
                    rightSite = int(rightSite)
                    donorBed = "\t".join(map(str, [chrom, rightSite - intronDist, rightSite + exonDist, juncName, ".", strand]))
                    donorList.append(donorBed)
                if not noThreeEnd:
                    leftSite = int(leftSite)
                    acceptorBed = "\t".join(map(str, [chrom, leftSite - exonDist, leftSite + intronDist, juncName, ".", strand]))
                    acceptorList.append(acceptorBed)
    donorBedObj = pybedtools.BedTool("\n".join(donorList), from_string=True)
    acceptorBedObj = pybedtools.BedTool("\n".join(acceptorList), from_string=True)
    junc2seq = {}
    if not noFiveEnd and not noThreeEnd:
        donorBedGetfastaRes = donorBedObj.sequence(refFasta, name=True, tab=True, s=True)
        acceptorBedGetfastaRes = acceptorBedObj.sequence(refFasta, name=True, tab=True, s=True)
        for i in str(open(donorBedGetfastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = str(i).strip("\n").split("\t")
            junc, baseSeq = infoList[0].split(":")[0], infoList[1]
            junc2seq[junc] = baseSeq
        for i in str(open(acceptorBedGetfastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = str(i).strip("\n").split("\t")
            junc, baseSeq = infoList[0].split(":")[0], infoList[1]
            junc2seq[junc] = junc2seq[junc] + "-" + baseSeq
    elif not noFiveEnd and noThreeEnd:
        donorBedGetfastaRes = donorBedObj.sequence(refFasta, name=True, tab=True, s=True)
        for i in str(open(donorBedGetfastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = str(i).strip("\n").split("\t")
            junc, baseSeq = infoList[0].split(":")[0], infoList[1]
            junc2seq[junc] = baseSeq
    elif noFiveEnd and not noThreeEnd:
        acceptorBedGetfastaRes = acceptorBedObj.sequence(refFasta, name=True, tab=True, s=True)
        for i in str(open(acceptorBedGetfastaRes.seqfn).read()).split("\n")[:-1]:
            infoList = str(i).strip("\n").split("\t")
            junc, baseSeq = infoList[0].split(":")[0], infoList[1]
            junc2seq[junc] = baseSeq
    d_tmp = [(v, k) for k, v in Counter(junc2seq.values()).iteritems()]
    d_tmp.sort(reverse=True)
    out = open(outFile, "w")
    for v, k in d_tmp:
        print >> out, "\t".join(map(str, [k, v]))
    out.close()

def splicesite2figure(refParams=None):
    refGenome = refParams.ref_genome
    splicesite2seq(refGenome, "IR.splicesite", outFile="IR.tmp")
    drawSSmotif(asMotif="IR.tmp", outPrefix="IR", asType="IR")
    splicesite2seq(refGenome, "IR.anno.splicesite", outFile="IR.anno.tmp")
    drawSSmotif(asMotif="IR.anno.tmp", outPrefix="IR.anno", asType="IR")
    splicesite2seq(refGenome, "IR.novel.splicesite", outFile="IR.novel.tmp")
    drawSSmotif(asMotif="IR.novel.tmp", outPrefix="IR.novel", asType="IR")
    splicesite2seq(refGenome, "SE.inc.splicesite", outFile="SE.inc.tmp")
    drawSSmotif(asMotif="SE.inc.tmp", outPrefix="SE.inc", asType="SE")
    splicesite2seq(refGenome, "SE.exc.splicesite", outFile="SE.exc.tmp")
    drawSSmotif(asMotif="SE.exc.tmp", outPrefix="SE.exc", asType="SE")
    splicesite2seq(refGenome, "A5SS.inc.splicesite", noThreeEnd=True, outFile="A5SS.inc.tmp")
    drawSSmotif(asMotif="A5SS.inc.tmp", outPrefix="A5SS.inc", asType="A5SS")
    splicesite2seq(refGenome, "A5SS.exc.splicesite", noThreeEnd=True, outFile="A5SS.exc.tmp")
    drawSSmotif(asMotif="A5SS.exc.tmp", outPrefix="A5SS.exc", asType="A5SS")
    splicesite2seq(refGenome, "A3SS.inc.splicesite", noFiveEnd=True, outFile="A3SS.inc.tmp")
    drawSSmotif(asMotif="A3SS.inc.tmp", outPrefix="A3SS.inc", asType="A3SS")
    splicesite2seq(refGenome, "A3SS.exc.splicesite", noFiveEnd=True, outFile="A3SS.exc.tmp")
    drawSSmotif(asMotif="A3SS.exc.tmp", outPrefix="A3SS.exc", asType="A3SS")

def remove_redun(seLst):
    """return a sublist of seLst with redundent ones (same block and junction)
     removed"""
    newSes = []
    seCodeSet = set()    # se.posCode: dn@st-ed@ac
    for se in seLst:
        if se.posCode in seCodeSet:
            continue
        else:
            newSes.append(se)
            seCodeSet.add(se.posCode)
    return newSes

def union_ses(refSes, pbSes, novel_count):
    """return a list of se which is the union of the 2 ses without redundency,
    change name of the se if necessary"""
    uSes = []
    seCodeSet = set()
    for se in refSes:
        se.name = "%s:%s" % (se.geneName, se.posCode)
        seCodeSet.add(se.posCode)
        uSes.append(se)

    for se in pbSes:
        if se.posCode in seCodeSet:
            continue
        else:
            # global novel_count
            novel_count.count += 1
            se.name = "NovelSE_%d:%s" % (novel_count.count, se.posCode)
            seCodeSet.add(se.posCode)
            uSes.append(se)
    return uSes

def cal_psi(se, jpos2count, dnpos2count):
    "calculate supCount, totalCount and score for se"
    se.supCount = jpos2count[se.jpos]
    se.totalCount = sum([tup[1] for tup in dnpos2count[se.dnpos]])
    se.score = int(float(se.supCount)/se.totalCount * 1000)

def identify_ses(chrom, strand, dn, ac_i, ac_o, refDct, pbDct, jpos2count, dnpos2count, novel_count):
    """return a list of bed12+ of SEs, additional fields: jpos, dnpos.
    """
    # find refs or pacbio reads covering dn to ac_o
    has_ref = False
    has_pb = False

    refs = find_refs(chrom, strand, dn, ac_i, ac_o, refDct, dnpos2count)
    if refs:
        has_ref = True
    pbs = find_refs(chrom, strand, dn, ac_i, ac_o, pbDct, dnpos2count)
    if pbs:      # use pacbio reads to varify SE structure
        has_pb = True

    if not has_ref and not has_pb:
        return []

    # check se for each ref or pb
    refSes = []
    if has_ref:
        for ref in refs:
            se = se_structure(strand, dn, ac_i, ac_o, ref)
            se.geneName = ref.geneName
            refSes.append(se)
    pbSes = []
    if has_pb:
        for pb in pbs:
            se = se_structure(strand, dn, ac_i, ac_o, pb)
            pbSes.append(se)

    # remove redun in refSe and pbSe, then remove redun in between
    refSes = remove_redun(refSes)
    pbSes = remove_redun(pbSes)
    seLst = union_ses(refSes, pbSes, novel_count)

    newSeLst = []
    for se in seLst:
        cal_psi(se, jpos2count, dnpos2count)
        newSeLst.append(se)
        # print >>out, se
    return newSeLst

def check_ses(chrom, dn, acs, refDct, pbDct, jpos2count, dnpos2count, novel_count):
    """return a list of SE(Bed12+) for enumerated dn-ac(ac is element in acs)
    that can be supported by ref in refLst or pb in pbLst.
    """
    # sort acs by position
    acs.sort()

    # check SE for dn with each 2 acs
    strand = "+" if dn < acs[0] else "-"
    seLst = []
    for ac1, ac2 in combinations(acs, 2):
        if strand == "+":
            ac_i, ac_o = ac1, ac2
        else:
            ac_i, ac_o = ac2, ac1
        seLst.extend(identify_ses(chrom, strand, dn, ac_i, ac_o, refDct, pbDct, jpos2count, dnpos2count, novel_count))
    return seLst

def scanEsByNGS(fref, has_bin, fjunc, fpb, outFile):
    # load gene structures
    refDct = {}
    with open(fref) as f:
        for line in f:
            if line.startswith("#"):
                continue
            ref = GenePredExtLine(line, bincolumn=has_bin)
            if ref.chrom in refDct:
                refDct[ref.chrom].append(ref)
            else:
                refDct[ref.chrom] = [ref]

    for chrom in refDct:
        refDct[chrom].sort(key=lambda r: r.txStart)

    # load pacbio reads
    pbDct = {}
    with open(fpb) as f:
        for line in f:
            if line.startswith("#"):
                continue
            read = Bed12(line)
            if read.chrom in pbDct:
                pbDct[read.chrom].append(read)
            else:
                pbDct[read.chrom] = [read]

    for chrom in pbDct:
        pbDct[chrom].sort(key=lambda r: r.chromStart)

    # load junctions into {chrom:{donor:[acceptors], ...}, ...}
    dn2ac = {}
    jpos2count = {}
    dnpos2count = {}      # {dnpos:[(ac,count), (ac,count), ...], ...}
    with open(fjunc) as f:
        for line in f:
            if line.startswith("#"):
                continue
            junc = Junction(line)

            jpos2count[junc.jPos] = junc.score
            if junc.dnPos in dnpos2count:
                dnpos2count[junc.dnPos].append((junc.ac, junc.score))
            else:
                dnpos2count[junc.dnPos] = [(junc.ac, junc.score)]

            if junc.strand == "+":
                dn = junc.donor
                ac = junc.acceptor
            else:
                dn = junc.acceptor
                ac = junc.donor

            if junc.chrom in dn2ac:
                if dn in dn2ac[junc.chrom]:
                    dn2ac[junc.chrom][dn].append(ac)
                else:
                    dn2ac[junc.chrom][dn] = [ac]
            else:
                dn2ac[junc.chrom] = {}
                dn2ac[junc.chrom][dn] = [ac]

    # check dn with multiple acs
    seLst_p = []
    seLst_n = []
    p_novel_count = Number()
    n_novel_count = Number()
    for chrom in dn2ac:
        for dn in dn2ac[chrom]:
            acs = list(set(dn2ac[chrom][dn]))
            if len(acs) > 1:
                pos_acs = [ac for ac in acs if ac > dn]
                neg_acs = [ac for ac in acs if ac < dn]
                if len(pos_acs) > 1:
                    seLst_p.extend(check_ses(chrom, dn, pos_acs, refDct, pbDct, jpos2count, dnpos2count, p_novel_count))
                if len(neg_acs) > 1:
                    seLst_n.extend(check_ses(chrom, dn, neg_acs, refDct, pbDct, jpos2count, dnpos2count, n_novel_count))
    out = open(outFile, "w")
    for i in seLst_p:
        print >>out, i
    for i in seLst_n:
        print >>out, i
    out.close()

class SE1(Bed12):
    def __init__(self, line):
        Bed12.__init__(self, line)
        self.geneName, self.se_info = self.name.split(":")
        self.supCount = int(self.record[12])
        self.totalCount = int(self.record[13])
        self.juncPoses = [Position(j) for j in self.record[14].split(",")]

    def __repr__(self):
        return "\t".join([Bed12.__repr__(self), repr(self.supCount),
                          repr(self.totalCount), ",".join([repr(j) for j in self.juncPoses])])


def find_refs1(se, refLst):
    refs = []
    for ref in refLst:
        if ref.strand != se.strand:
            continue
        else:
            for junc in se.juncPoses:
                if (junc.chromStart in ref.exonEnds or junc.chromEnd in ref.exonStarts):
                    refs.append(ref)
                    break
    return refs

def change_name(se, refDct, errorOut):
    "change name if necessary"
    if se.chrom not in refDct:
        return 1
    refs = find_refs1(se, refDct[se.chrom])
    if refs:
        geneNames = set([ref.geneName for ref in refs])
        if len(geneNames) > 1:
            return 2
        else:
            gName = geneNames.pop()
            print >> errorOut, "%s\t%s" % (se.geneName, gName)
            se.geneName = gName
            se.name = ":".join([se.geneName, se.se_info])
            return 0
    else:
        return 1

def assignGeneNameToSE(fref, has_bin, fes, outFile, errorOutFile):
    # load gene structures
    refDct = {}
    with open(fref) as f:
        for line in f:
            if line.startswith("#"):
                continue
            ref = GenePredExtLine(line, bincolumn=has_bin)
            if ref.chrom in refDct:
                refDct[ref.chrom].append(ref)
            else:
                refDct[ref.chrom] = [ref]
    for chrom in refDct:
        refDct[chrom].sort(key=lambda r: r.txStart)

    out = open(outFile, "w")
    errorOut = open(errorOutFile, "w")
    with open(fes) as f:
        for line in f:
            if line.startswith("#"):
                print >>out, line,
                continue
            se = SE1(line)
            if se.geneName.startswith("Novel"):
                change_name(se, refDct, errorOut)
                print >>out, se
            else:
                print >>out, line,
    out.close()
    errorOut.close()

